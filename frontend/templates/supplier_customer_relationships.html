<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supplier - Customer Relationships</title>
    <!-- Update the link to your CSS file -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/openlayers/dist/ol.js"></script>
</head>
<body>
    <div id="popup" class="ol-popup">
        <a href="#" id="popup-closer" class="ol-popup-closer"></a>
        <div id="popup-content"></div>
    </div>
    <div class="container">
        <div class="left-section">
            <div class="inputs-section">
                <div class="header">
                    <div class="logo-title-container">
                        <!-- Update the image source path -->
                        <img src="{{ url_for('static', filename='imgs/bag.png') }}" alt="MarketPulse360 Logo" class="logo">
                        <h1>MarketPulse360</h1>
                    </div>
                    <div class="home-title-container">
                        <h1>Home</h1>
                        <!-- Use JavaScript to go back to the previous page -->
                        <a href="javascript:history.back()">
                            <img src="{{ url_for('static', filename='imgs/home.png') }}" alt="Home" class="home-icon">
                        </a>
                    </div>
                </div>
                <h2 class="title">Supplier - Customer Relationships</h2>
                <div class="inputs">
                    <div class="input-group">
                        <label for="supplier">Supplier Name</label>
                        <select id="supplier">
                            {% for supplier in suppliers %}
                                <option value="{{ supplier }}">{{ supplier }}</option>
                            {% endfor %}
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="customer-id">Customer ID</label>
                        <input type="text" id="customer-id">
                    </div>
                    <div class="input-group">
                        <label for="date-range">Date Range for Transactions</label>
                        <input type="date" id="start-date">
                        <input type="date" id="end-date">
                    </div>
                </div>
                <button id="submit">Submit</button>
            </div>
        </div>
        <div class="right-section">
            <div class="network-graph">
                <h3 class="section-title">Supplier-wise Breakdown of Customer Purchases</h3> <!-- Title for the Network Graph -->
                <div id="network-graph"></div>
            </div>
            <div id="map2" class="map-section2"></div> <!-- Map Section -->
        </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script type="text/javascript">
        // ... Map Setup ...
        $(document).ready(function() {
            var vectorLayer; // Layer for the features
            var arrowLayer; // Layer for the arrows
            var map = new ol.Map({
                target: 'map2', // Ensure this ID matches the map container
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.XYZ({
                            attributions: '© MapTiler © OpenStreetMap contributors',
                            url: 'https://api.maptiler.com/maps/streets/{z}/{x}/{y}.png?key=uIMFZoCyLmKWTvmPj2JG',
                            maxZoom: 19
                        })
                    })
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat([121, 23.5]), // Center on Taiwan
                    zoom: 7 // Adjust zoom level as needed
                })
            });
            $('#submit').click(function(event) {
                event.preventDefault();

                var selectedSupplier = $('#supplier').val();
                var selectedCustomer = $('#customer-id').val();
                var selectedStartDate = $('#start-date').val();
                var selectedEndDate = $('#end-date').val();

                $.ajax({
                    url: "{{ url_for('update_map_net_sc') }}",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({ 
                        supplier: selectedSupplier, 
                        customer: selectedCustomer,
                        start_date: selectedStartDate, 
                        end_date: selectedEndDate  
                    }),
                    dataType: "json",
                    success: function(response) {
                        // Remove existing layers
                        if (vectorLayer) map.removeLayer(vectorLayer);
                        if (arrowLayer) map.removeLayer(arrowLayer)
                        // Create features for suppliers and customers
                        var supplierFeatures = createFeatures(response.suppliers, '#cd3700', 'Supplier', true);
                        var customerFeatures = createFeatures(response.customers, '#ff6103', 'Customer ID', true);

                        // Create arrow features
                        var arrowFeatures = createArrowFeatures(response.suppliers, response.customers);

                        // Create and add vector layer to the map
                        vectorLayer = new ol.layer.Vector({
                            source: new ol.source.Vector({
                                features: supplierFeatures.concat(customerFeatures)
                            })
                        });
                        map.addLayer(vectorLayer);

                        // Create and add arrow layer to the map
                        arrowLayer = new ol.layer.Vector({
                            source: new ol.source.Vector({
                                features: arrowFeatures
                            })
                        });
                        map.addLayer(arrowLayer);
                    }
                });
            });

            function createFeatures(data, color, labelProperty, additionalProperties) {
                return data.map(function(item) {
                    var feature = new ol.Feature({
                        geometry: new ol.geom.Polygon(item.geometry.coordinates).transform('EPSG:4326', 'EPSG:3857'),
                        label: item.properties[labelProperty],
                        // Add additional properties here
                        City: item.properties.City,
                        District: item.properties.District,
                        Supplier: item.properties.Supplier,
                        CustomerID: item.properties.CustomerID
                    });

                    feature.setStyle(new ol.style.Style({
                        fill: new ol.style.Fill({ color: color }),
                        text: new ol.style.Text({
                            text: item.properties[labelProperty],
                            fill: new ol.style.Fill({ color: '#fff' }),
                            stroke: new ol.style.Stroke({ color: '#000', width: 3 })
                        })
                    }));

                    return feature;
                });
            }

            function createArrowFeatures(suppliers, customers) {
                var arrowFeatures = [];

                suppliers.forEach(supplier => {
                    var supplierGeometry = new ol.geom.Polygon(supplier.geometry.coordinates).transform('EPSG:4326', 'EPSG:3857');
                    var supplierEdges = supplierGeometry.getLinearRing(0).getCoordinates();

                    customers.forEach(customer => {
                        var customerGeometry = new ol.geom.Polygon(customer.geometry.coordinates).transform('EPSG:4326', 'EPSG:3857');
                        var customerCentroidPoint = customerGeometry.getInteriorPoint(); // This is a Point geometry
                        var customerCentroid = customerCentroidPoint.getCoordinates(); // Transformed coordinates

                        var closestPointOnSupplier = findClosestPoint(supplierEdges, customerCentroid);
                        var closestPointOnCustomer = findClosestPoint(customerGeometry.getLinearRing(0).getCoordinates(), closestPointOnSupplier);

                        var arrowGeometry = new ol.geom.LineString([closestPointOnSupplier, closestPointOnCustomer]);

                        var arrowFeature = new ol.Feature({
                            geometry: arrowGeometry
                        });

                        // Calculate the angle for the arrowhead
                        var dx = closestPointOnCustomer[0] - closestPointOnSupplier[0];
                        var dy = closestPointOnCustomer[1] - closestPointOnSupplier[1];
                        var rotation = Math.atan2(dy, dx);

                        // Style for the arrow line
                        var lineStyle = new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: '#0056b3',
                                width: 3
                            })
                        });

                        // Style for the arrowhead
                        var arrowHeadStyle = new ol.style.Style({
                            geometry: new ol.geom.Point(closestPointOnCustomer),
                            image: new ol.style.RegularShape({
                                fill: new ol.style.Fill({ color: '#0056b3' }),
                                points: 3,
                                radius: 10,
                                rotation: rotation,
                                angle: Math.PI / 2 // Adjust the angle as necessary
                            })
                        });

                        arrowFeature.setStyle([lineStyle, arrowHeadStyle]);

                        arrowFeatures.push(arrowFeature);
                    });
                });

                return arrowFeatures;
            }






            function findClosestPoint(edges, point) {
                var closestPoint = null;
                var minDistance = Infinity;

                function calculateClosestPointOnSegment(segStart, segEnd, point) {
                    var dx = segEnd[0] - segStart[0];
                    var dy = segEnd[1] - segStart[1];
                    if (dx !== 0 || dy !== 0) {
                        var t = ((point[0] - segStart[0]) * dx + (point[1] - segStart[1]) * dy) / (dx * dx + dy * dy);

                        if (t > 1) {
                            t = 1;
                        } else if (t < 0) {
                            t = 0;
                        }

                        var nearest = [segStart[0] + t * dx, segStart[1] + t * dy];
                        var dist = calculateDistance(point, nearest);

                        return { point: nearest, distance: dist };
                    }
                    return null;
                }

                function calculateDistance(point1, point2) {
                    var dx = point1[0] - point2[0];
                    var dy = point1[1] - point2[1];
                    return Math.sqrt(dx * dx + dy * dy);
                }

                for (var i = 0; i < edges.length - 1; i++) {
                    var start = edges[i];
                    var end = edges[i + 1];
                    var result = calculateClosestPointOnSegment(start, end, point);

                    if (result && result.distance < minDistance) {
                        closestPoint = result.point;
                        minDistance = result.distance;
                    }
                }

                return closestPoint;
            }


            function createFeatures(data, color, labelProperty) {
                return data.map(function(item) {
                    var featureProperties = {
                        geometry: new ol.geom.Polygon(item.geometry.coordinates).transform('EPSG:4326', 'EPSG:3857'),
                        City: item.properties.City,
                        District: item.properties.District
                    };

                    if (item.properties.Supplier === 'NA') {
                        // This is a customer
                        featureProperties['CustomerID'] = item.properties['Customer ID'];
                    } else {
                        // This is a supplier
                        featureProperties['Supplier'] = item.properties.Supplier;
                    }

                    var feature = new ol.Feature(featureProperties);

                    feature.setStyle(new ol.style.Style({
                        fill: new ol.style.Fill({ color: color }),
                        text: new ol.style.Text({
                            text: item.properties[labelProperty],
                            fill: new ol.style.Fill({ color: '#fff' }),
                            stroke: new ol.style.Stroke({ color: '#000', width: 3 })
                        })
                    }));

                    return feature;
                });
            }


            // Popup functionality
            var popupContainer = document.getElementById('popup');
            var popupContent = document.getElementById('popup-content');
            var popupCloser = document.getElementById('popup-closer');
            var overlay = new ol.Overlay({
                element: popupContainer,
                autoPan: true,
                autoPanAnimation: {
                    duration: 250
                }
            });
            map.addOverlay(overlay);
            popupCloser.onclick = function() {
                overlay.setPosition(undefined);
                return false;
            };

            map.on('singleclick', function(event) {
                var feature = map.forEachFeatureAtPixel(event.pixel, function(feature) {
                    return feature;
                });

                if (feature) {
                    var properties = feature.getProperties();
                    var contentHtml = 'City: ' + properties.City +
                                    '<br>District: ' + properties.District;

                    if (properties.Supplier && properties.Supplier !== 'NA') {
                        contentHtml += '<br>Supplier: ' + properties.Supplier;
                    } else if (properties.CustomerID) {
                        contentHtml += '<br>Customer ID: ' + properties.CustomerID;
                    }

                    popupContent.innerHTML = contentHtml;
                    overlay.setPosition(event.coordinate);
                } else {
                    overlay.setPosition(undefined);
                }
            });







        });

    </script>



    <script>
        $(document).ready(function() {
            $('#submit').click(function(event) {
                event.preventDefault();  // Prevents the default form submission action
                var selectedSupplier = $('#supplier').val();
                var selectedCustomer = $('#customer-id').val();
                var selectedStartDate = $('#start-date').val();
                var selectedEndDate = $('#end-date').val();

                // Form validation
                if (!selectedSupplier || !selectedCustomer || !selectedStartDate || !selectedEndDate) {
                    return;  // Stops the function if validation fails
                }

                // Send AJAX request to Flask backend
                $.ajax({
                    url: "{{ url_for('get_network_data') }}",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({ 
                    supplier: selectedSupplier, 
                    customer: selectedCustomer,
                    start_date: selectedStartDate, 
                    end_date: selectedEndDate 
                    }),
                    dataType: "json",
                    success: function(response) {
                        // Render the network graph with the received data
                        renderNetworkGraph(response.nodes, response.links);
                    }
                });
            });

            function renderNetworkGraph(nodes, links) {
                // Clear previous graph
                d3.select("#network-graph svg").remove();

                const width = document.getElementById("network-graph").clientWidth;
                const height = 400;
                const linkDistance = 200;
                const sourceColor = "#cd3700"; // Example color for source nodes
                const targetColor = "#ff6103"; // Example color for target nodes
                // Function to calculate node radius
                function getNodeRadius(id) {
                    return Math.max(20, id.length * 4); // Adjust as needed
                }

                const svg = d3.select("#network-graph").append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .call(d3.zoom().on("zoom", function (event) {
                        svg.attr("transform", event.transform);
                    }))
                    .append("g");

                // Define color scale
                const colorScale = d3.scaleSequential((t) => d3.interpolateBlues(0.5 + t * 0.5))
                    .domain([0, 100]); // Assuming 'value' is between 0 and 100

                // Define scale for the link stroke width
                const strokeWidthScale = d3.scaleLinear()
                    .domain([0, d3.max(links, d => d.value)])
                    .range([1, 5]); // Adjust the range as needed

                const simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(linkDistance))
                    .force("charge", d3.forceManyBody())
                    .force("center", d3.forceCenter(width / 2, height / 2));

                const linkGroup = svg.append("g")
                    .attr("class", "links")
                    .selectAll("g")
                    .data(links)
                    .join("g");

                const link = linkGroup.append("line")
                    .attr("stroke-width", d => strokeWidthScale(d.value))
                    .attr("stroke", d => colorScale(d.value));

                const linkText = linkGroup.append("text")
                    .text(d => d.value.toFixed(0)) // Round the value to an integer
                    .attr("fill", "black") // Text color
                    .attr("font-size", 18) // Adjust font size as needed
                    .attr("text-anchor", "middle"); // Center the text on the link

                const node = svg.append("g")
                    .selectAll("circle")
                    .data(nodes)
                    .join("circle")
                    .attr("r", d => getNodeRadius(d.id))
                    .attr("fill", d => {
                        // Check if the node is a source node
                        const isSource = links.some(link => link.source.id === d.id);
                        return isSource ? sourceColor : targetColor;
                    });

                const label = svg.append("g")
                    .selectAll("text")
                    .data(nodes)
                    .join("text")
                    .text(d => d.id)
                    .attr("text-anchor", "middle") // Center text horizontally
                    .attr("dominant-baseline", "central") // Center text vertically
                    .attr("font-size", 15)
                    .attr("fill", "white"); // Text color

                simulation.on("tick", () => {
                    link.attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    linkText
                        .attr("x", d => (d.source.x + d.target.x) / 2)
                        .attr("y", d => (d.source.y + d.target.y) / 2);

                    node.attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    label.attr("transform", d => `translate(${d.x}, ${d.y})`);
                });
            }
        });
    </script>

<script>
    $(document).ready(function() {
        $('#submit').click(function(event) {
            event.preventDefault();  // Prevents the default form submission action

            var selectedSupplier = $('#supplier').val();
            var selectedCustomer = $('#customer-id').val();
            var selectedStartDate = $('#start-date').val();
            var selectedEndDate = $('#end-date').val();

            // Form validation
            if (!selectedSupplier || !selectedCustomer || !selectedStartDate || !selectedEndDate) {
                alert('Please fill all fields before submitting.');
                return;  // Stops the function if validation fails
            }

            // If validation passes, proceed with the AJAX request
            $.ajax({
                url: "{{ url_for('update_map_net_sc') }}", 
                type: "POST",
                contentType: "application/json",
                data: JSON.stringify({ 
                    supplier: selectedSupplier, 
                    customer: selectedCustomer,
                    start_date: selectedStartDate, 
                    end_date: selectedEndDate 
                }),
                dataType: "json",
                success: function(response) {
                    // Logic to update the map and network graph based on the response
                },
                error: function(xhr, status, error) {
                    // Handle errors here, such as displaying a message to the user
                }
            });
        });
    });
</script>

</body>
</html>
