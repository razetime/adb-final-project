<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supplier - Customer Relationships</title>
    <!-- Update the link to your CSS file -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/openlayers/dist/ol.js"></script>
</head>
<body>
    <div id="popup" class="ol-popup">
        <a href="#" id="popup-closer" class="ol-popup-closer"></a>
        <div id="popup-content"></div>
    </div>
    <div class="container">
        <div class="left-section">
            <div class="inputs-section">
                <div class="header">
                    <div class="logo-title-container">
                        <!-- Update the image source path -->
                        <img src="{{ url_for('static', filename='imgs/bag.png') }}" alt="MarketPulse360 Logo" class="logo">
                        <h1>MarketPulse360</h1>
                    </div>
                    <div class="home-title-container">
                        <h1>Home</h1>
                        <!-- Use JavaScript to go back to the previous page -->
                        <a href="javascript:history.back()">
                            <img src="{{ url_for('static', filename='imgs/home.png') }}" alt="Home" class="home-icon">
                        </a>
                    </div>
                </div>
                <h2 class="title">Supplier - Customer Relationships</h2>
                <div class="inputs-container">
                    <div class="inputs">
                        <div class="input-group">
                            <label for="supplier-id">Supplier ID</label>
                            <input type="text" id="supplier-id" placeholder="Enter Supplier ID">
                        </div>
                        <div class="input-group">
                            <label for="customer-id">Customer ID</label>
                            <input type="text" id="customer-id" placeholder="Enter Customer ID">
                        </div>
                    </div>
                </div>
                <button id="submit">Submit</button>

                <div id="node-info">
                    Click on a node to see its information here.
                </div>

            </div>
        </div>
        <div class="right-section">
            <div class="network-graph">
                <h3 class="section-title">Supplier-wise Breakdown of Customer Purchases</h3> <!-- Title for the Network Graph -->
                <div id="network-graph"></div>
            </div>
            <div id="map2" class="map-section2"></div> <!-- Map Section -->
        </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script type="text/javascript">
        // ... Map Setup ...
        $(document).ready(function() {
            var vectorLayer; // Layer for the features
            var arrowLayer; // Layer for the arrows
            var map = new ol.Map({
                target: 'map2', // Ensure this ID matches the map container
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.XYZ({
                            attributions: '© MapTiler © OpenStreetMap contributors',
                            url: 'https://api.maptiler.com/maps/streets/{z}/{x}/{y}.png?key=uIMFZoCyLmKWTvmPj2JG',
                            maxZoom: 19
                        })
                    })
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat([121, 23.5]), // Center on Taiwan
                    zoom: 7 // Adjust zoom level as needed
                })
            });
            $('#submit').click(function(event) {
                event.preventDefault();

                var selectedSupplierId = $('#supplier-id').val();
                var selectedCustomer = $('#customer-id').val();

                $.ajax({
                    url: "{{ url_for('update_map_net_sc') }}",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({ 
                        supplier_id: selectedSupplierId, 
                        customer: selectedCustomer,
                    }),
                    dataType: "json",
                    success: function(response) {
                        // Remove existing layers
                        if (vectorLayer) map.removeLayer(vectorLayer);
                        if (arrowLayer) map.removeLayer(arrowLayer)
                        // Create features for suppliers and customers
                        var supplierFeatures = createFeatures(response.suppliers, '#cd3700', 'Supplier', true);
                        var customerFeatures = createFeatures(response.customers, '#ff6103', 'Customer ID', true);

                        // Create arrow features
                        var arrowFeatures = createArrowFeatures(response.suppliers, response.customers);

                        // Create and add vector layer to the map
                        vectorLayer = new ol.layer.Vector({
                            source: new ol.source.Vector({
                                features: supplierFeatures.concat(customerFeatures)
                            })
                        });
                        map.addLayer(vectorLayer);

                        // Create and add arrow layer to the map
                        arrowLayer = new ol.layer.Vector({
                            source: new ol.source.Vector({
                                features: arrowFeatures
                            })
                        });
                        map.addLayer(arrowLayer);
                    }
                });
            });

            function createFeatures(data, color, labelProperty, additionalProperties) {
                return data.map(function(item) {
                    var feature = new ol.Feature({
                        geometry: new ol.geom.Polygon(item.geometry.coordinates).transform('EPSG:4326', 'EPSG:3857'),
                        label: item.properties[labelProperty],
                        // Add additional properties here
                        City: item.properties.City,
                        District: item.properties.District,
                        Supplier: item.properties.Supplier,
                        CustomerID: item.properties.CustomerID
                    });

                    feature.setStyle(new ol.style.Style({
                        fill: new ol.style.Fill({ color: color }),
                        text: new ol.style.Text({
                            text: item.properties[labelProperty],
                            fill: new ol.style.Fill({ color: '#fff' }),
                            stroke: new ol.style.Stroke({ color: '#000', width: 3 })
                        })
                    }));

                    return feature;
                });
            }

            function createArrowFeatures(suppliers, customers) {
                var arrowFeatures = [];

                suppliers.forEach(supplier => {
                    var supplierGeometry = new ol.geom.Polygon(supplier.geometry.coordinates).transform('EPSG:4326', 'EPSG:3857');
                    var supplierEdges = supplierGeometry.getLinearRing(0).getCoordinates();

                    customers.forEach(customer => {
                        var customerGeometry = new ol.geom.Polygon(customer.geometry.coordinates).transform('EPSG:4326', 'EPSG:3857');
                        var customerCentroidPoint = customerGeometry.getInteriorPoint(); // This is a Point geometry
                        var customerCentroid = customerCentroidPoint.getCoordinates(); // Transformed coordinates

                        var closestPointOnSupplier = findClosestPoint(supplierEdges, customerCentroid);
                        var closestPointOnCustomer = findClosestPoint(customerGeometry.getLinearRing(0).getCoordinates(), closestPointOnSupplier);

                        var arrowGeometry = new ol.geom.LineString([closestPointOnSupplier, closestPointOnCustomer]);

                        var arrowFeature = new ol.Feature({
                            geometry: arrowGeometry
                        });

                        // Calculate the angle for the arrowhead
                        var dx = closestPointOnCustomer[0] - closestPointOnSupplier[0];
                        var dy = closestPointOnCustomer[1] - closestPointOnSupplier[1];
                        var rotation = Math.atan2(dy, dx);

                        // Style for the arrow line
                        var lineStyle = new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: '#0056b3',
                                width: 3
                            })
                        });

                        // Style for the arrowhead
                        var arrowHeadStyle = new ol.style.Style({
                            geometry: new ol.geom.Point(closestPointOnCustomer),
                            image: new ol.style.RegularShape({
                                fill: new ol.style.Fill({ color: '#0056b3' }),
                                points: 3,
                                radius: 10,
                                rotation: rotation,
                                angle: Math.PI / 2 // Adjust the angle as necessary
                            })
                        });

                        arrowFeature.setStyle([lineStyle, arrowHeadStyle]);

                        arrowFeatures.push(arrowFeature);
                    });
                });

                return arrowFeatures;
            }






            function findClosestPoint(edges, point) {
                var closestPoint = null;
                var minDistance = Infinity;

                function calculateClosestPointOnSegment(segStart, segEnd, point) {
                    var dx = segEnd[0] - segStart[0];
                    var dy = segEnd[1] - segStart[1];
                    if (dx !== 0 || dy !== 0) {
                        var t = ((point[0] - segStart[0]) * dx + (point[1] - segStart[1]) * dy) / (dx * dx + dy * dy);

                        if (t > 1) {
                            t = 1;
                        } else if (t < 0) {
                            t = 0;
                        }

                        var nearest = [segStart[0] + t * dx, segStart[1] + t * dy];
                        var dist = calculateDistance(point, nearest);

                        return { point: nearest, distance: dist };
                    }
                    return null;
                }

                function calculateDistance(point1, point2) {
                    var dx = point1[0] - point2[0];
                    var dy = point1[1] - point2[1];
                    return Math.sqrt(dx * dx + dy * dy);
                }

                for (var i = 0; i < edges.length - 1; i++) {
                    var start = edges[i];
                    var end = edges[i + 1];
                    var result = calculateClosestPointOnSegment(start, end, point);

                    if (result && result.distance < minDistance) {
                        closestPoint = result.point;
                        minDistance = result.distance;
                    }
                }

                return closestPoint;
            }


            function createFeatures(data, color, labelProperty) {
                return data.map(function(item) {
                    var featureProperties = {
                        geometry: new ol.geom.Polygon(item.geometry.coordinates).transform('EPSG:4326', 'EPSG:3857'),
                        City: item.properties.City,
                        District: item.properties.District
                    };

                    if (item.properties.Supplier === 'NA') {
                        // This is a customer
                        featureProperties['CustomerID'] = item.properties['Customer ID'];
                    } else {
                        // This is a supplier
                        featureProperties['Supplier'] = item.properties.Supplier;
                    }

                    var feature = new ol.Feature(featureProperties);

                    feature.setStyle(new ol.style.Style({
                        fill: new ol.style.Fill({ color: color }),
                        text: new ol.style.Text({
                            text: item.properties[labelProperty],
                            fill: new ol.style.Fill({ color: '#fff' }),
                            stroke: new ol.style.Stroke({ color: '#000', width: 3 })
                        })
                    }));

                    return feature;
                });
            }


            // Popup functionality
            var popupContainer = document.getElementById('popup');
            var popupContent = document.getElementById('popup-content');
            var popupCloser = document.getElementById('popup-closer');
            var overlay = new ol.Overlay({
                element: popupContainer,
                autoPan: true,
                autoPanAnimation: {
                    duration: 250
                }
            });
            map.addOverlay(overlay);
            popupCloser.onclick = function() {
                overlay.setPosition(undefined);
                return false;
            };

            map.on('singleclick', function(event) {
                var feature = map.forEachFeatureAtPixel(event.pixel, function(feature) {
                    return feature;
                });

                if (feature) {
                    var properties = feature.getProperties();
                    var contentHtml = 'City: ' + properties.City +
                                    '<br>District: ' + properties.District;

                    if (properties.Supplier && properties.Supplier !== 'NA') {
                        contentHtml += '<br>Supplier: ' + properties.Supplier;
                    } else if (properties.CustomerID) {
                        contentHtml += '<br>Customer ID: ' + properties.CustomerID;
                    }

                    popupContent.innerHTML = contentHtml;
                    overlay.setPosition(event.coordinate);
                } else {
                    overlay.setPosition(undefined);
                }
            });







        });

    </script>



    <script>
        $(document).ready(function() {
            $('#submit').click(function(event) {
                event.preventDefault();  // Prevents the default form submission action
                var selectedSupplierId = $('#supplier-id').val();
                var selectedCustomer = $('#customer-id').val();

                // Form validation
                if (!selectedSupplierId || !selectedCustomer) {
                    return;  // Stops the function if validation fails
                }

                // Send AJAX request to Flask backend
                $.ajax({
                    url: "{{ url_for('get_network_data') }}",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify({ 
                    supplier_id: selectedSupplierId, 
                    customer: selectedCustomer,
                    }),
                    dataType: "json",
                    success: function(response) {
                        // Render the network graph with the received data
                        renderNetworkGraph(response.nodes, response.links);
                    },
                    error: function(error) {
                        console.log("Error fetching graph data: ", error);
                    }
                });
            });

            let groupRectangles = {}; // Store rectangles for each group
            let groupLabels = {}; // Store labels for each group

            function renderNetworkGraph(nodes, links) {
                const width = document.getElementById("network-graph").clientWidth;
                const height = document.getElementById("network-graph").clientHeight;

                const svg = d3.select("#network-graph").append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .style("background-color", "lightblue") // Set the background color here
                    .call(d3.zoom().on("zoom", function (event) {
                        svg.attr("transform", event.transform);
                    }))
                    .append("g");

                const color = d3.scaleOrdinal(d3.schemeCategory10);
                

                // Define the vertical positions for each group
                const groupYPositions = {
                    "User": height,
                    "ParentOrder": height * 2,
                    "Order": height * 3,
                    "Product": height * 4,
                    "Supplier": height * 5
                };

                // Custom force to align nodes vertically based on their group
                function forceGroupY(groupYPositions) {
                    return function(alpha) {
                        nodes.forEach(function(node) {
                            if (node.group in groupYPositions) {
                                node.y += (groupYPositions[node.group] - node.y) * alpha * 0.1;
                            }
                        });
                    };
                }

                const simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(350))
                    .force("charge", d3.forceManyBody().strength(-280))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("groupY", forceGroupY(groupYPositions))
                    .force("collision", d3.forceCollide().radius(120)); // Collision radius to prevent overlap

                const link = svg.append("g")
                    .selectAll("line")
                    .data(links)
                    .join("line")
                    .attr("stroke", "#999")
                    .attr("stroke-opacity", 0.6)
                    .attr("stroke-width", 6); // Increase the stroke width for thicker lines

                // Modify labels based on group
                const groupLabelsMapping = {
                    "User": "Customer",
                    "ParentOrder": "Parent Orders",
                    "Order": "Orders",
                    "Product": "Products",
                    "Supplier": "Suppliers"
                };

                const linkLabel = svg.append("g")
                    .selectAll("text")
                    .data(links)
                    .join("text")
                    .text(d => d.type)
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);

                // Function to display node information
                function displayNodeInfo(node) {
                    const nodeInfoDiv = document.getElementById("node-info");

                    // Debugging: Log the node object to console
                    console.log("Selected node:", node);

                    let infoHtml = ``;

                    switch (node.group) {
                        case "User":
                            infoHtml += `Customer<br>ID: ${node.customer_id || "N/A"}`;
                            break;
                        case "ParentOrder":
                            infoHtml += `Parent Order<br>ID: ${node.parent_ord_id || "N/A"}<br>Datetime: ${node.datetime || "N/A"}<br>Parent Order Number: ${node.parent_ord_num || "N/A"}`;
                            break;
                        case "Order":
                            infoHtml += `Order<br>ID: ${node.order_id || "N/A"}<br>Ship Method: ${node.ship_method || "N/A"}`;
                            break;
                        case "Product":
                            infoHtml += `Product<br>ID: ${node.prod_id || "N/A"}<br>Name: ${node.name || "N/A"}`;
                            break;
                        case "Supplier":
                            infoHtml += `Supplier<br>ID: ${node.supplier_id || "N/A"}<br>Name: ${node.name || "N/A"}`;
                            break;
                        default:
                            // Handle unknown group
                            infoHtml += `<br>No additional info available`;
                    }

                    nodeInfoDiv.innerHTML = infoHtml;
                }



                const node = svg.append("g")
                    .selectAll("circle")
                    .data(nodes)
                    .join("circle")
                    .attr("r", d => calculateRadius(d))
                    .attr("fill", d => color(d.group))
                    .on("click", function(event, d) {
                        displayNodeInfo(d); // Pass the node data 'd' to the displayNodeInfo function
                    });

                
                
                const label = svg.append("g")
                    .selectAll("text")
                    .data(nodes)
                    .join("text")
                    .text(d => {
                        // Choose label text based on node group
                        switch(d.group) {
                            case "User": return d.customer_id || "N/A";
                            case "ParentOrder": return d.parent_ord_num || "N/A";
                            case "Order": return d.order_id || "N/A";
                            case "Product": return d.name || "N/A";
                            case "Supplier": return d.name || "N/A";
                            default: return "N/A"; // Fallback for unknown groups
                        }
                    })
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "central")
                    .attr("fill", "white");
                
                    // Function to calculate node radius based on label text
                function calculateRadius(d) {
                    let label;
                    switch(d.group) {
                        case "User": label = d.customer_id || "N/A"; break;
                        case "ParentOrder": label = d.parent_ord_num || "N/A"; break;
                        case "Order": label = d.order_id || "N/A"; break;
                        case "Product": label = d.name || "N/A"; break;
                        case "Supplier": label = d.name || "N/A"; break;
                        default: label = "N/A"; // Fallback for unknown groups
                    }
                    const averageCharWidth = 15; // Average pixel width of a character; adjust as needed
                    const textLength = label.length * averageCharWidth;
                    return Math.max(20, textLength / 2); // Ensure a minimum radius
                }

                // Initialize group rectangles and labels
                const nodeGroups = d3.group(nodes, d => d.group);
                nodeGroups.forEach((groupNodes, groupName) => {
                    groupRectangles[groupName] = svg.append("rect")
                        .style("fill", "none")
                        .style("stroke", color(groupName))
                        .style("stroke-width", 2)
                        .style("stroke-dasharray", "3, 3");

                    groupLabels[groupName] = svg.append("text")
                        .attr("text-anchor", "middle")
                        .text(groupLabelsMapping[groupName] || groupName)
                        .style("font-size", "14px")
                        .style("fill", color(groupName));
                });
                    
                
                simulation.on("tick", () => {
                    link.attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    linkLabel
                        .attr("x", d => (d.source.x + d.target.x) / 2)
                        .attr("y", d => (d.source.y + d.target.y) / 2);

                    node.attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    label.attr("x", d => d.x)
                        .attr("y", d => d.y);

                    // Update group rectangles and labels
                    nodeGroups.forEach((groupNodes, groupName) => {
                        let minX = d3.min(groupNodes, d => d.x - calculateRadius(d)) || 0;
                        let maxX = d3.max(groupNodes, d => d.x + calculateRadius(d)) || 0;
                        let minY = d3.min(groupNodes, d => d.y - calculateRadius(d)) || 0;
                        let maxY = d3.max(groupNodes, d => d.y + calculateRadius(d)) || 0;

                        let width = maxX - minX + 20;
                        let height = maxY - minY + 20;
                        let x = minX - 10;
                        let y = minY - 10;

                        groupRectangles[groupName]
                            .attr("x", x)
                            .attr("y", y)
                            .attr("width", width)
                            .attr("height", height);

                        groupLabels[groupName]
                            .attr("x", x + width / 2)
                            .attr("y", y - 10);
                    });
                });
            }


        });
    </script>

<script>
    $(document).ready(function() {
        $('#submit').click(function(event) {
            event.preventDefault();  // Prevents the default form submission action

            var selectedSupplierId = $('#supplier-id').val();
            var selectedCustomer = $('#customer-id').val();

            // Form validation
            if (!selectedSupplierId || !selectedCustomer) {
                alert('Please fill all fields before submitting.');
                return;  // Stops the function if validation fails
            }

            // If validation passes, proceed with the AJAX request
            $.ajax({
                url: "{{ url_for('update_map_net_sc') }}", 
                type: "POST",
                contentType: "application/json",
                data: JSON.stringify({ 
                    supplier_id: selectedSupplierId, 
                    customer: selectedCustomer,
                }),
                dataType: "json",
                success: function(response) {
                    // Logic to update the map and network graph based on the response
                },
                error: function(xhr, status, error) {
                    // Handle errors here, such as displaying a message to the user
                }
            });
        });
    });
</script>

</body>
</html>
